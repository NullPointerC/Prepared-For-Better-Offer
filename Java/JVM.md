### 什么时候会发生栈内存溢出？

![image-20220310145028084](https://gitee.com/cao_ziqiang/img/raw/master/20220310145028.png)

栈是线程私有的，栈的生命周期是和线程一致的；

当栈帧数量超过虚拟机允许的最大栈深度时，就会产生栈内存溢出，如不合理递归；

可以通过调整参数调整JVM栈大小；

### JVM内存模型？

![image-20220310145308510](https://gitee.com/cao_ziqiang/img/raw/master/20220310145308.png)

程序计数器：线程私有，一块很小的空间，用于指示当前线程的行号，当前虚拟机正在执行的线程指令地址；

虚拟机栈：线程私有，每个方法执行时都会创建栈帧，保存局部变量表，动态连接，方法返回，操作栈；

本地方法栈：线程私有的，保存native方法的信息；

堆：所有线程共享的最大的一块内存，所有的对象实例和数组几乎都需要在堆上来分配内存，也是经常发生垃圾回收的区域；

方法区：存放已被加载的类信息，常量，静态变量，JIT编译的一些即时数据；

在JDK1.8中不存在方法区的概念，而是被元数据区取代；被分为两部分，一部分存放加载类信息，一部分存储运行时的常量池；

### Java引用机制

#### 强引用

`Object object=new Object()` 这样的变量声明和定义就会产生对该对象的强引用。只要对象有强引用指向，并且GC Root可达，那么Java内存回收时，即使内存濒临耗尽，也不会回收该对象。

#### 软引用

引用力弱与强引用，用在非必须对象的场景。在即将OOM之前，垃圾回收器会把这些引用指向的对象加入回收范围，以获得更多的内存空间，让程序能够继续健康运行。主要用来缓存服务器中间计算结果及不需要实时保存的用户行为等。

#### 弱引用

引用强度较前两者更弱，也是用来描述非必须对象的。如果弱引用指向的对象只存在弱引用这一条线路，则在下一次 Y GC （年轻代GC）时会被回收。由于YGC的时间不确定性，弱引用何时被回收也具有不确定性。弱引用主要用于指向某个易消失的对象，在强引用断开后，此引用不会劫持对象，调用weakReference.get() 会返回空。

#### 虚引用

定义完成后，就无法通过该引用获取指向的对象，为对象设置虚引用的唯一目的，就是希望能在这个对象被回收时，收到一个系统通知。

虚引用与软引用和弱引用的一个区别在于，虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中

### JVM中一次完整的GC是什么样子的?对象如何晋升到老年代?

JDK1.8中分为新生代和老年代：

![image-20220310150056283](https://gitee.com/cao_ziqiang/img/raw/master/20220310150056.png)

新生代又分为Eden区和幸存者区，幸存者区又分为幸存者0区to和幸存者1区from。

大小大致为1：1：8。

当Eden区满时，会触发一次MinorGC，轻量级的GC，收集新生代的垃圾，存活下来的对象就会被放到幸存者区。

对于大对象，需要较大的连续区域，会被直接分配到老年区。

对于一次MinorGC存活下来的对象，被分配到幸存者区的，年龄会+1，每次minor GC存活的对象年龄+1，比如阀值为15时，即可晋升老年代，大对象除外。

参数-XX:+MaxTenuringThreshold可配置对象年龄的阀值,最大是15。

当老年代满时，无法存放更多对象，就会触发full GC来回收空间；

还有MajorGC也是发生在老年代，经常伴随一次Minor GC来回收垃圾；

### 聊聊Java中的垃圾回收算法?

Java中有四种垃圾回收算法，分别是标记清除法、标记整理法、复制算法、分代收集算法;

#### 标记清除法

算法分别标记和清除两个阶段，首先根据可达性分析遍历一遍内存，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

主要不足：

①.效率问题，标记和清除两个过程的效率都不高；

②.空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片过多可能会导致以后程序运行时需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收；

如下图所示：

![image.png](https://gitee.com/cao_ziqiang/img/raw/master/20220310151321.webp)



#### 标记整理法

分为标记->整理->清除三个过程，首先根据可达性分析，遍历内存，把存活对象和垃圾对象进行标记，第二步将所有存活的对象向一段进行移动，边界以外的对象都会被回收。

适用于存活对象多垃圾少的场景，不会产生碎片空间，需要消耗整理内存空间的时间；

缺点是仍然需要进行对象移动，一定程度上降低了效率。

![image.png](https://gitee.com/cao_ziqiang/img/raw/master/20220310151758.webp)

#### 复制算法

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。

![image.png](https://gitee.com/cao_ziqiang/img/raw/master/20220310151924.webp)

这样虽然解决了内存内存碎片问题，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半，会浪费一半的内存空间。

#### 分代收集算法

根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

- 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
- 老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用”标记—整理”算法来进行回收。

![image.png](https://gitee.com/cao_ziqiang/img/raw/master/20220310152457.webp)

### 分别说说这四种算法的特点以及在哪使用?

![image.png](https://gitee.com/cao_ziqiang/img/raw/master/20220310153703.webp)

CMS垃圾回收器就是使用的标记清除算法。

Serial Old收集器使用的标记整理算法，是Serial收集器的老年代版本，使用单线程的标记 - 整理算法。

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。

G1是复制算法+标记整理算法。

Serial，单线程模式，用于新生代的垃圾回收，使用复制算法；

parNew，多线程模型，用于新生代回收，也使用复制算法；

Parallel Scavenge，使用并行的方式进行垃圾回收，也是新生代的会后，主要采用复制算法，与ParNew类似；

### 如何判断一个对象是否存活?







