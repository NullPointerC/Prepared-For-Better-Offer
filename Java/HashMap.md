### hashmap的数据插入原理是怎么样的？

![image-20220309202946733](https://gitee.com/cao_ziqiang/img/raw/master/20220309202946.png)

如果链表长度大于8，转化为红黑树；

如果红黑树中节点个数小于6，转回链表；

以上条件都要基于数组的长度大于64时，才会进行转化；

### HashMap怎么设定初始容量大小?

一般如果new HashMap()不传值，默认大小是16，负载因子是0.75。

如果自己传入初始大小k，初始化大小为大于k的2的整数次方，例如如果传10，大小为16。

![image-20220309210013740](https://gitee.com/cao_ziqiang/img/raw/master/20220309210013.png)

在1.8中，传入的初始容量cap，真实容量会被设置为距离cap最近的2的整数次方。

在1.7中，传入的初始容量cap，真实容量会被设置为cap。

### HashMap的哈希函数设计是怎样的?

hash函数是先拿到key 的hashcode，是一个32位的int值，然后让hashcode的高16位和低16位进行异或操作。

原因：

①.尽可能降低hash碰撞；

②.低位掩码就是利用高位掩码替换低位掩码，也称为扰动函数；

1.7中是做了4次扰动，实际效果和1.8扰动一次差异不大，所以也就采用一次扰动。

### 1.8还有别的优化吗?

数据结构层面：在1.8中底层数据结构数组+链表改成了数组+链表或红黑树;

插入方式：链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7将新元素放到数组中，原始节点作为新节点的后继节点，1.8遍历链表将元素放置到链表的最后;

原因如下：

![image-20220310134028145](https://gitee.com/cao_ziqiang/img/raw/master/20220310134028.png)

扩容：扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置,1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小;

插入时：1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容;

