### Redis和Memcache有什么区别?你是如何选用的?

memcache使用多线程异步I/O，可以利用CPU多核优势，使用内存存储数据，只支持K-V数据结构，不支持持久化和主从同步，失效策略使用延迟过期策略。

容量满时会使用LRU策略剔除，key不超过250字节，value不超过1M字节，最大失效时间为30天。

redis使用单线程模式，redis支持持久化，不仅可以用作缓存，还直接nosql数据库，还支持多种数据类型，支持主从同步。

### 你用到过哪些Redis的数据结构?是在什么场景下用的?

Redis 内部使用字典来存储不同类型的数据，Redis支持的string、hash、list、set和sorted set 5种类型。

string使用SDS动态字符串（Simple Dynamic String）实现，提前分配冗余空间来减少内存频繁分配；

list由ziplist（压缩列表）和linkedlist（双链表）实现，ziplist存储在连续内存上，不适合修改操作，linkedlist花销大，地址不连续，容易产生碎片，从3.2之后产生了quicklist数据结构，本身是一个双向无环链表；他的每一个节点都是一个ziplist，将二者相互结合；

hash由ziplist和hashtable两种实现，当hashtable中所有key和value的长度都小于64时，并且键值对数量小于512时使用ziplist，超过时使用hashtable；

set类型的内部实现是通过intset和hashtable实现，当集合中元素小于512时，且都是数值，就是用intset；

sorted set的实现可以是ziplist和skiplist跳表来实现，当有序集合中元素个数小于128个并且所有元素的长度都小于64字节使用ziplist，否则转换成skiplist；

### Redis有哪些持久化方式，区别是什么?

redis提供两种方式进行持久化，一种是RDB持久化，一种是AOF持久化。

RDB的实现方式是：将Reids在内存中的数据库记录定时dump到磁盘上；

AOF的实现方式是：将Reids的操作日志以追加的方式写入文件；

RDB存储的是redis的快照，采用二进制压缩存储，AOF存储操作命令；

### Redis的过期机制是怎样的?Redis有哪些淘汰策略?

redis过期策略是︰定期删除+惰性删除

每隔100毫秒，随机抽查一些key来检查是否过期。

redis中内容满时，会采用内存淘汰机制，使用`no-eviction`，`allkeys-lru`，`allkeys-random`，`volatile-lru`，`volatile-random`，`volatile-ttl`。

在redis4中，加入了`lfu`算法。

### 淘汰策略的算法？

通常淘汰策略使用的算法有:FIFO、LRU、LFU。

FIFO使用队列来实现，![image-20220312210323392](http://static.codenote.xyz/img/20220312210323.png)



LRU队列：

![image-20220312210402969](http://static.codenote.xyz/img/20220312210403.png)

LFU算法：

![image-20220312210512861](http://static.codenote.xyz/img/20220312210512.png)

### 如何保证Redis的高并发和高可用?

单机可以使用主从架构，一主多从

![image-20220312210736141](http://static.codenote.xyz/img/20220312210736.png)



### 如何使用 Redis 实现延时队列?

电商系统中的订单，一直处于未支付状态，可以使用延时队列；

定期检查退款状态，订单是否已经退款成功；

订单长时间没有收到下游系统状态通知，如何实现阶梯式的同步状态策略；

### 什么是缓存雪崩、缓存穿透和缓存击穿，会造成什么问题，如何解决?

缓存雪崩：当缓存服务器重启或者大量的key集中过期，会给数据库带来很大压力；

解决方案：key的失效期分散开，不同的key设置不同的失效时间；

设置二级缓存，数据不一定一致；

允许数据的脏读，key失效了也读取到数据，但是需要根据项目的场景；

缓存穿透：一般的缓存系统都是按照key去查询的，如果不存在相对应的key时，不存在对应的value时，就会去后端的数据中查找。缓存穿透指在高并发场景下，查询的key不存在，数据会穿过缓存，查询数据库，导致数据库压力过大而延时；

解决方案：针对查询结果为空的情况也进行缓存；当然，这样会造成缓存有太多空值占用空间；

更优的方案：使用布隆过滤器，查询的时候先去布隆过滤器中查找key是否存在，如果不存在直接返回，存在则查询缓存和数据库；

缓存击穿：对于设置了过期的key，key在某些时间超高的访问，即热点数据，这个缓存在某个时间点过期了，恰好有很多并发请求发送来，请求发现缓存过期，从后端DB加载并且设置到缓存中，大量的db可能会把DB压垮；

解决方案：分布式锁控制访问的线程，set nx互斥锁判断，其他线程等待，保证不会有大并发访问数据库；

### 缓存和数据库数据是不一致时，会造成什么问题，如何解决?

强一致性是比较难实现的，不过我们可以实现最终一致性。

时序控制因为不是原子性操作，所以不一定是可行的，保证数据的最终一致性可以使用“延时双删”策略。

即更新数据库时，同时删除缓存项，等读取的时候，再填充缓存；

2s后再删一次缓存项；

设置缓存过期的时间，如10s，一个小时；

将缓存删除失败的记录到日志中，利用脚本再次删除；

或者使用数据库的bin log异步淘汰key，利用canal将bin log采集发送到MQ，通过ACK机制确认处理删除的缓存；

ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RMQ,RMQ收到反馈后才将此消息从队列中删除；

### 什么是数据并发竞争，会造成什么问题，如何解决?

多个redis的客户端，同时进行set同一个key，引起的并发问题。本来按顺序修改为2，3，4但是顺序变成了4，3，2。

第一种方案：分布式锁 + 时间戳；

![image-20220312213550237](http://static.codenote.xyz/img/20220312213550.png)

第二种方案:利用消息队列；

将set操作放入MQ中，串行化消费消息；

### 单线程的Redis为什么这么快?

1.redis的操作都是在内存中进行的，它的持久化只是数据的备份，所以正常情况下内存和硬盘不会进行频繁的交换；

2.单线程没有锁，不用竞争锁，也不会有线程上下文切换的问题；

3.IO多路复用模型；

4.持久化采用fork子进程执行；





