### 进程和线程的区别？

串行化：初期的计算机智能串行执行任务，并且需要长时间等待用户输入；

批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行；

进程：进程独占内存空间，保存各自运行状态，相互间不干扰且可以互相切换，为并爱处理在务提供了可能；

线程：共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行；

区别如下：

1. 进程是资源分配的最小单位，线程是CPU调度的最小单位
2. 进程是抢占处理机的调度单位;线程属于某个进程，共享其资源；
3. 线程只由堆栈寄存器、程序计数器和TCB组成；

### Java中进程和线程的关系？

1. Java对操作系统提供的功能进行封装，包括进程和线程；
2. 运行一个程序会产生一个进程，进程包含至少一个线程；
3. 每个进程对应一个JVM实例，多个线程共享JVM里的堆；
4. Java采用单线程编程模型，程序会自动创建主线程；
5. 主线程可以创建子线程，原则上要后于子线程完成执行；

###   Thread中的start和run方法的区别？

![image-20220315204603801](https://gitee.com/cao_ziqiang/img/raw/master/20220315204603.png)

调用start()方法会创建一个新的子线程并启动；

run()方法只是Thread的一个普通方法的调用；

### Thread和Runnable是什么关系？

Thread是实现了Runnable接口的类，使得run支持多线程；

因类的单一继承原则，推荐多使用Runnable接口；

### 如何给run()方法传参？

1. 构造函数传参；
2. 成员变量传参；
3. 回调函数传参；

### 如何实现处理线程的返回值？

1. 主线程等待法，实现简单，但是缺点需要自己实现循环等待的逻辑，需要等待的变量变多时，代码臃肿；
2. 使用Thread类的join()阻塞当前线程以等待子线程处理完毕；
3. 通过Callable接口实现:通过FutureTask Or 线程池获取；

### 线程的状态？

新建(New):创建后尚未启动的线程的状态，new出来后还没有执行start方法的状态；

运行(Runnable):包含Running和Ready，有可能正在执行或者等待CPU分配时间片；

无限期等待(Waiting):不会被分配CPU执行时间，需要显式被唤醒；如没有设置Timeout参数的Object.wait方法，没有设置Timeout方法的Thread.join()方法，LockSupport.park方法；

限期等待(Timed Waiting):在一定时间后会由系统自动唤醒；

 阻塞(Blocked):等待获取排它锁；

结束(Terminated):已终止线程的状态，线程已经结束执行；

### sleep和wait的区别？

1. sleep是Thread类的方法，wait是Object类中定义的方法；
2. sleep()方法可以在任何地方使用，wait()方法只能在synchronized方法或synchronized块中使用；
3. Thread.sleep只会让出CPU，不会导致锁行为的改变，Object.wait不仅让出CPU，还会释放已经占有的同步资源锁；

### notify和notifyAll的区别？

锁池（EntrySet）：

假设线程A已经拥有了某个对象（不是类）的锁，而其它线程B、C想要调用这个对象的某个synchronized方法（或者块），由于B、c线程在进入对象的synchronized方法（或者块）之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A所占用，此时B、c线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池。

等待池（WaitSet）：

假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。

1. notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；
2. notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；

### yield？

当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。

并且不会让出锁资源。

### 如何中断线程？

已经被抛弃的方法：
1. 通过调用stop()方法停止线程；
2. 通过调用suspend()和resume()方法；

目前正在使用的方法：

调用interrupt()，通知线程应该中断了；

1. 如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常；
2. 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响；

### 线程状态以及状态之间的转换？

![image-20220315214152766](https://gitee.com/cao_ziqiang/img/raw/master/20220315214152.png)

### synchronized？

线程安全的原因：

1. 存在共享数据(也称临界资源)；
2. 存在多条线程共同操作这些共享数据；

解决办法：

同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作；

synchronized也就是完成这样的作用，也成为互斥锁。

互斥锁的特性：

1. 互斥性:即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块(复合操作)进行访问。互斥性也称为操作的原子性；
2. 可见性︰必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值)，否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致；

注意点：**synchronized锁的不是代码，锁的都是对象**；

<hr/>

synchronized的分类：

1. 根据获取的锁的分类:获取对象锁和获取类锁。

	获取对象锁的用法：

	1. 同步代码块( `synchronized (this)`, `synchronized(类实例对象)`)，锁是小括号()中的实例对象;
	2. 同步非静态方法( `synchronized method` )，锁是当前对象的实例对象；

	获取类锁的用法：
	
	1. 同步代码块（`synchronized（类.class）`），锁的是小括号()中的类对象(Class对象)；
	2. 同步静态代码（`synchronized static method`），锁是当前对象的类对象（Class对象）；
	
	对象锁和类锁的区别：
	
	1. 有线程访问对象的同步代码块时，另外的线程可以访问对象的非同步代码块；
	2. 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另—个访问对象的同步代码块的线程会被阻塞；
	3. 若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞；
	4. 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的线程会被阻塞，反之亦然；
	5. 同一个类的不同对象的对象锁互不干扰；
	6. 类锁由于也是一种特殊的对象锁，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的；
	7. 类锁和对象锁互不干扰；
	
### synchronized底层实现原理？

实现`synchronized`的基础：

- Java对象头；
- Monitor；

hotspot对象在内存中的布局：

1. 对象头；
2. 示例数据；
3. 对齐填充；

#### 对象头的结构

| 虚拟机位数  |       头对象结构       |                             说明                             |
| :---------: | :--------------------: | :----------------------------------------------------------: |
| 32 / 64 bit |       Mark Word        |   默认存储对象的hashCode，分代年龄，锁类型，锁标志位等信息   |
| 32 / 64 bit | Class Metadata Address | 类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的数据 |

Mark Word如下：

![image-20220316215926786](https://gitee.com/cao_ziqiang/img/raw/master/20220316215926.png)

`Minitor`：每个Java对象天生自带了一把看不见的锁。

`Monitor`锁的竞争、获取与释放：

![image-20220316220247247](https://gitee.com/cao_ziqiang/img/raw/master/20220316220247.png)

#### 重入的概念

从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入。

在Java的早期版本，`synchronized`属于重量级锁，依赖于`Mutex Lock`来实现，OS线程之间切换需要从用户态切换到内核态，开销大。从JDK6开始，从JVM层面改善了，`synchronized`引入了自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等技术。

#### 自旋锁

在许多情况下，共享数据的锁定状态只会持续很短的时间，为了这段时间去挂起和切换线程的开销很大，在多处理器环境下，可以让没有获取到锁的线程等待一会，但不放弃CPU时间的行为，也就是自旋，通过让线程执行忙循环等待锁的释放，不让出CPU资源，和`sleep`不一样的是，`sleep`会放弃CPU的执行时间。

缺点：若锁被其他线程长时间占用，会带来许多性能上的开销。

因此自旋等待的时间，要设置一定的限度，如果自旋超过了限度的尝试次数，仍然没有获取到锁时，就应该要挂起线程。

#### 自适应自旋锁

自旋的次数不再固定；

由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定；

#### 锁消除

JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。

#### 锁粗化

原则上，在加同步锁时，应该尽可能地把锁的作用域限制到最小，即只在共享数据的作用域内才加锁。

#### synchronized的四种状态

无锁	->	偏向锁	->	轻量级锁	->	重量级锁

偏向锁：

大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，因此，为了降低同一线程获得锁的代价，引入偏向锁。

核心思想：

如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁结构，当该线程再次请求锁时:无需再做任何同步操作，即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁以及当前线程Id等于Mark Word的ThreadID即可，这样就省去了大量有关锁申请的操作。

不适合用于锁竞争比较激烈的多线程场合，因为每次获取锁的线程都可能不同。

注意：如果存在不同线程进入竞争锁，并不会马上膨胀为重量级锁，而是先升级为轻量级锁。

轻量级锁：

轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。

适应的场景：线程交替执行同步块。

若存在同一时间有多个线程竞争同一个锁时，就会导致轻量级锁膨胀为重量级锁。

轻量级锁加锁的过程：

1. 代码进入同步块的时候，如果同步对象锁的状态为无锁状态（锁标志位为"01"状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的`Mark Word`的拷贝，官方称之为`Displaced Mark Word`。这时候的堆栈与对象头的状态如图所示：![image-20220316224207341](https://gitee.com/cao_ziqiang/img/raw/master/20220316224207.png)
2. 拷贝对象头中的Mark Word复制到锁记录中；
3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针,并将Lock record里的owner指针指向object markword。如果更新成功，则执行步骤4，否则执行步骤5；
4. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word的锁标志位设置为"00"，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图所示：![image-20220316224439784](https://gitee.com/cao_ziqiang/img/raw/master/20220316224439.png)
5. 如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就耍膨胀为重量级锁，锁标志的状态值变为"10”，Mark Word中存储的就是指向重量级锁(互斥量）的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁，自旋咱们前面讲过，就是为了不让线程阻塞，而采用循环去获取锁的过程。

![image-20220316224708052](https://gitee.com/cao_ziqiang/img/raw/master/20220316224708.png)

### ReentrantLock

位于JUC.locks包下；

基于AQS实现；

能够实现比synchronized更细粒度的控制，比如控制fairness；

调用lock后，必须使用unlock；

性能也未必比synchronized高，并且也是可重入时；

<hr/>

ReentrantLock公平性的设置：

```java
ReentrantLock fairLock = new ReentrantLock(true);
```

参数为true时，倾向于把锁赋予给等待时间最长的线程；

公平锁∶获取锁的顺序按先后调用lock方法的顺序。

非公平锁:抢占的顺序不一定，看运气。

synchronized是非公平锁。

