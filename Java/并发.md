### 进程和线程的区别？

串行化：初期的计算机智能串行执行任务，并且需要长时间等待用户输入；

批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行；

进程：进程独占内存空间，保存各自运行状态，相互间不干扰且可以互相切换，为并爱处理在务提供了可能；

线程：共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行；

区别如下：

1. 进程是资源分配的最小单位，线程是CPU调度的最小单位
2. 进程是抢占处理机的调度单位;线程属于某个进程，共享其资源；
3. 线程只由堆栈寄存器、程序计数器和TCB组成；

### Java中进程和线程的关系？

1. Java对操作系统提供的功能进行封装，包括进程和线程；
2. 运行一个程序会产生一个进程，进程包含至少一个线程；
3. 每个进程对应一个JVM实例，多个线程共享JVM里的堆；
4. Java采用单线程编程模型，程序会自动创建主线程；
5. 主线程可以创建子线程，原则上要后于子线程完成执行；

###   Thread中的start和run方法的区别？

![image-20220315204603801](https://gitee.com/cao_ziqiang/img/raw/master/20220315204603.png)

调用start()方法会创建一个新的子线程并启动；

run()方法只是Thread的一个普通方法的调用；

### Thread和Runnable是什么关系？

Thread是实现了Runnable接口的类，使得run支持多线程；

因类的单一继承原则，推荐多使用Runnable接口；

### 如何给run()方法传参？

1. 构造函数传参；
2. 成员变量传参；
3. 回调函数传参；

### 如何实现处理线程的返回值？

1. 主线程等待法，实现简单，但是缺点需要自己实现循环等待的逻辑，需要等待的变量变多时，代码臃肿；
2. 使用Thread类的join()阻塞当前线程以等待子线程处理完毕；
3. 通过Callable接口实现:通过FutureTask Or 线程池获取；

### 线程的状态？

新建(New):创建后尚未启动的线程的状态，new出来后还没有执行start方法的状态；

运行(Runnable):包含Running和Ready，有可能正在执行或者等待CPU分配时间片；

无限期等待(Waiting):不会被分配CPU执行时间，需要显式被唤醒；如没有设置Timeout参数的Object.wait方法，没有设置Timeout方法的Thread.join()方法，LockSupport.park方法；

限期等待(Timed Waiting):在一定时间后会由系统自动唤醒；

 阻塞(Blocked):等待获取排它锁；

结束(Terminated):已终止线程的状态，线程已经结束执行；

### sleep和wait的区别？

1. sleep是Thread类的方法，wait是Object类中定义的方法；
2. sleep()方法可以在任何地方使用，wait()方法只能在synchronized方法或synchronized块中使用；
3. Thread.sleep只会让出CPU，不会导致锁行为的改变，Object.wait不仅让出CPU，还会释放已经占有的同步资源锁；

### notify和notifyAll的区别？

锁池（EntrySet）：

假设线程A已经拥有了某个对象（不是类）的锁，而其它线程B、C想要调用这个对象的某个synchronized方法（或者块），由于B、c线程在进入对象的synchronized方法（或者块）之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A所占用，此时B、c线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池。

等待池（WaitSet）：

假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。

1. notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；
2. notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；

### yield？

当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。

