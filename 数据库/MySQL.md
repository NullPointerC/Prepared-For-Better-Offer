### RDBMS的架构

![image-20220225154652997](https://gitee.com/cao_ziqiang/img/raw/master/20220225154653.png)

### 为什么要使用索引？

一条查询的流程到达引擎后，如果没有索引，会需要进行全表扫描，数据量比较大时，操作会比较慢；

引入索引是为了快速查询数据，避免对全表进行扫描，提升检索效率。

### 索引的数据结构

二叉查找树，即BST，用BST作为索引大部分情况下可以提供查询效率，时间复杂度为`O(logn)`，但是缺点在于，如果经过多此插入或删除，BST没有自调整功能，很容易退化成链表，查询时间复杂度也会退化成`O(n)`。即使使用`AVL`树等自平衡二叉树来做调整，可以使平均查找的时间复杂度降低，但是程序运行的瓶颈其实不在CPU，而在于I/O，即使有了自平衡能力，每次也是只能读取一个子树进入内存，需要进行一次I/O，而I/O的花费比较大，二叉树的深度比较大，当检索的深度提升时，就会进行I/O。

不管是BST，AVLTree，红黑树也好，每个节点最多也只能有两个孩子，数据块会非常多，所以树的高度也会很高，I/O次数也会非常多，是非常耗时的。所以就需要让树的高度矮一些，让每个节点的孩子多一些，这样就可以降低树的高度；

B-Tree，也称平衡多路查找树，如果每个节点最多有`m`个孩子，那么这个树就是`m`阶B树。

定义如下：

根节点至少包括两个孩子；

树中每个节点最多含有`m`个孩子(`m`>=2)；

除根节点和叶子节点外，每个节点都至少有`ceil(m/2)`个孩子；

所有叶子节点都位于同一层；

如下展示了3阶B树。

![image-20220225160445034](https://gitee.com/cao_ziqiang/img/raw/master/20220225160445.png)

通常情况下，`m`都会设置为非常大，降低树的高度。

![image-20220225161504427](https://gitee.com/cao_ziqiang/img/raw/master/20220225161504.png)

B+-Tree

B+树是B树的变种，其定义基本与B树相同，除了：

非叶子节点的子树指针与关键字个数相同；

非叶子节点的子树指针P[i]，指向关键字值[K[i], K[i+1])的子树；

非叶子节点仅用来索引，数据都保存在叶子节点中；

所有叶子节点均有一个链指针指向下一个叶子结点，并按大小关系链接；

![image-20220225162532434](https://gitee.com/cao_ziqiang/img/raw/master/20220225162532.png)

所以说B+树所有的检索都是跟部开始，检索到叶子节点才可以停止，而非叶子节点不存储数据，可以存储更多的关键字，B+树相对于B树来说，更矮。

叶子节点链接起来了的话，更加便于我们在叶子节点上做范围统计；

所以B+树更加适合做存储索引，磁盘读写代价更低， 

B+树的查询效率更加稳定，所有的查询都必须到叶子节点才停止；

B+树更有利于对数据库的扫描，B+树需要遍历叶子节点，就可以减少对数据库的全表扫描；

hash索引

有些存储引擎还支持hash表作为存储引擎，可以直接根据hash函数找到数据的块。

 ![image-20220225163631830](https://gitee.com/cao_ziqiang/img/raw/master/20220225163631.png)

哈希索引查询效率高，但是仅仅满足"="或"in"，不能使用范围查询，因为查询的范围`(a,b)`经过哈希运算后并不能保证`a`和`b`的大小关系。

且无法被用来避免数据的排序操作；

不能利用部分索引键查询；

不能避免表扫描；

遇到大量hash值相等时，bucket可能会退化成链表；

bitmap索引

![image-20220225164142944](https://gitee.com/cao_ziqiang/img/raw/master/20220225164143.png)

如果仅仅是为了统计一些字段，可以使用bitmap。但是需要注意MySQL并不支持bitmap，Oracle支持bitmap。

### 密集索引和稀疏索引

密集索引文件中的每个搜索码值都对应一个索引值；

稀疏索引文件只为索引码的某些值建立索引项；

![image-20220225164615093](https://gitee.com/cao_ziqiang/img/raw/master/20220225164615.png)

对于InnoDB，若一个主键被定义，则该主键作为密集索引；

如果没有主键被定义，那么该表的第一个唯一非空索引则作为密集索引；

若不满足以上条件，innodb的内部会生成一个隐藏的主键作为密集索引，改主键是一个六字节的列，会随着插入的行自增；

**非主键索引并不存储行数据，而是存储相关键位和其对应的主键值，包含两次查找**

### 聚簇索引和非聚簇索引

![image-20220225183451863](https://gitee.com/cao_ziqiang/img/raw/master/20220225183518.png)



![image-20220225185826998](https://gitee.com/cao_ziqiang/img/raw/master/20220225185827.png)

可以发现innodb的索引和数据是存储在同一个文件中的，而MyISAM的索引和数据是分别存放的。

### 如何定位并优化慢查询SQL？

根据慢日志定位慢查询SQL；

几个关键的参数，`long_query_time`表示一条查询超过了这个时间就被记录进慢SQL日志中，`slow_query_log`表示是否开启慢SQL查询，`slow_query_log_file`表示慢SQL日志的存放地址；

一般情况下需要把`long_query_time`设置成`1s`，`slow_query_log`打开。

```mysql
# 打开慢查询日志
set global slow_query_log = on;
# 设置慢查询时间
set global long_query_time = 1;
# 并且重启客户端,或者修改my.cnf或者my.ini配置文件,因为这只是一次修改,而配置文件是永久性的
```

可以使用下述语句来统计**本次会话**中记录的慢SQL数量

```mysql
show status like "%slow_queries%"
```

慢SQL记录日志文件如下所示：

![image-20220225191212581](https://gitee.com/cao_ziqiang/img/raw/master/20220225191212.png)

使用explain等工具分析SQL；

explain用于描述MySQL如何执行查询操作。

`id`表示SQL执行的顺序，`type`表示MySQL找到数据行的方式，性能好坏如下所示

![image-20220225191450761](https://gitee.com/cao_ziqiang/img/raw/master/20220225191450.png)

`extra`表示额外的信息，如果出现如下2项，意味着MySQL根本没有使用索引，效率会受到很大的影响。

![image-20220225191630857](https://gitee.com/cao_ziqiang/img/raw/master/20220225191630.png)

修改SQL或者尽量让SQL走索引；

修改查询字段为有索引的字段或者给字段加上索引；

```mysql
alter table t1 add index idx_col(col_name);
```

### 联合索引的最左匹配原则

假设有`a`和`b`两列组成的联合索引，当我们查询`where a = x and b = y?`的时候就会走索引，调用`a=x`也会走索引，而调用`b=y`就不会走索引，所以也称为最左匹配原则。

MySQL会一直向右匹配直到遇到范围查询`>`，`<`，`between`，`like`就停止匹配，比如`a = 3 and b = 4 and c < 5 and d = 6`，如果建立`(a,b,c,d)`顺序的索引，`d`是用不到索引的，如果建立`(a,b,d,c)`的索引则可以用到，`a,b,d`的顺序可以调整。 

最左匹配的成因：MySQL创建复合索引的规则是对第一个索引字段排序，在第一个字段排序的基础上再对第二个字段排序，因为第一个是绝对有序的，而第二个不一定，所以用第二个字段做where判断用不上索引。

### 索引是建立的越多越好吗？

数据量小的表不需要建立索引，建立会增加额外的索引开销；

数据变更需要维护索引，因此更多的索引意味着更多的维护成本，索引也是需要空间和时间去维护的；

更多的索引意味着也需要更多的空间；

### MyISAM与InnoDB关于锁方面的区别是什么？

锁定用于确保事务完整性和数据库一致性。 锁定可以防止用户读取其他用户正在更改的数据，并防止多个用户同时更改相同的数据。 如果不使用锁定，数据库中的数据可能在逻辑上变得不正确，而针对这些数据进行查询可能会产生想不到的结果。

行级锁是Mysql中锁定粒度最细的一种锁，表示**只针对当前操作的行进行加锁**。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为`共享锁` 和 `排他锁`。

特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

表级锁是MySQL中锁定粒度最大的一种锁，表示**对当前操作的整张表加锁**，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为`表共享读锁`（共享锁）与`表独占写锁`（排他锁）。

特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁

特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

<hr/>

MyISAM默认用的是表级锁，不支持行级锁；

MYISAM对于读操作时是共享锁，对于写操作是排他锁，对于查询也可以加上`for update`加上排他锁。

InnoDB默认用的是行级锁，也支持表级锁；

InnoDB只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。

在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。

行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。

所以MYISAM适合读表，适合频繁执行全表count的语句，对数据的增删改频率不高，适合没有事务的表；

INNODB适合数据增删改查都是否频繁的场景，适合可靠性要求比较高支持事务的系统；

### 数据库事务的四大特性？

事务是指对于数据库的一系列操作，每个操作作为单个的逻辑单元执行的工作，要么全部执行，要么全部都不执行。

ACID是指事务的4个特性。

原子性：事务包含的全部操作，要么全部执行，要么全部失败回滚；

一致性：事务操作保证数据库从一个一致的状态到另一个一致的状态；

隔离性：多个事务并发执行时一个事务并不影响其他事务的执行；

持久性：一个事务一旦提交，对数据库的修改应该永久保存在数据库中，即使数据库宕机了，也能恢复对数据库的修改操作；

### 事务隔离级别以及各级别下的并发访问问题？

更新丢失：一个事务的更新覆盖了另一个事务的更新。（原因是因为当前事务没有读取到其他提交的事务，但是数据库的所有级别都可以防止这样的情况发送）

处理方式：mysql所有事务隔离级别在数据库层面上均可避免。![image-20220225210757446](https://gitee.com/cao_ziqiang/img/raw/master/20220225210757.png)

脏读：`READ-COMMITED`事务隔离级别以上可避免，指一个事务读取到了其他未提交的事务，也就是脏数据。

处理方式：需要把事务隔离级别设置为`READ-COMMITED`，**只能读其他事务已经提交了的事务**。

不可重复读：`REPEATABLE-READ`事务隔离级别以上可以避免，指一个事务在还未对数据进行更新的情况下，其他事务提交后的数据，每次执行读操作的事务读取的数据不一致。

处理方式：需要把事务的隔离级别设置为`REPEATTABLE-READ`可重复读，多次读取会读取到最终的数据。

幻读：`SERIALIZABLE`事务隔离级别可避免，指的是事务A读取若干行，事务B以插入或删除的方式来修改事务A的结果集，导致事务A看起来像出现幻觉一样。

![image-20220226145923989](https://gitee.com/cao_ziqiang/img/raw/master/20220226145924.png)

### InnoDB可重复读隔离级别下如何避免幻读？

当前读：`select ... lock in share mode`，`select ... for update`，`update`，`insert`，`delete`都是加了锁的SQL语句，当执行执行后，读取的是最新数据，而且保证其他并发事务不能修改当前事务。第一条加的是共享锁，其他的语句加的是排他锁。

快照读:不加速的非阻塞读，`select`。

表象：快照读（非阻塞读）--伪MVCC

内在：next-key锁（行锁+gap锁）

对主键索引或者唯一索引的where条件如果全部命中,那么不会使用gap锁,只会加记录数;

如果where部分或者全都不命中,那么就会加gap锁;

gap锁会用在非唯一索引或者不走索引的当前读中。

### RC、RR级别下的InnoDB的非阻塞读如何实现？

 数据行里的DB_TRX_ID(标记事务的ID)、DB_ROLL_PTR(回滚指针)、DB_ROW_ID(行号)字段很关键；

undo日志，存储老版日志；

![image-20220226152634475](https://gitee.com/cao_ziqiang/img/raw/master/20220226152634.png)

read view；

