[剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/ "剑指 Offer 49. 丑数")
![](https://img2022.cnblogs.com/blog/2272548/202202/2272548-20220212171856542-435598347.png)
多路归并+dp，可以看出所有的丑数都是由质因数$2$，$3$，$5$乘上比它更小的丑数得到的，于是，现在假设有3个数组，分别是： 
A：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......}

B：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}

C：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}
那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？
而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。
定义当前每个数组的位置idx[]数组，分别都先指向${1,1,1}$，再进行多路归并。
```java
class Solution {
    public int nthUglyNumber(int n) {
        // 丑数数组
        int[] dp = new int[n + 1];
        dp[1] = 1;
        int[] idx = {1, 1, 1};
        for(int i = 2; i <= n; i++) {
            while(dp[idx[0]] * 2 <= dp[i - 1]) {
                idx[0]++;
            }
            while(dp[idx[1]] * 3 <= dp[i - 1]) {
                idx[1]++;
            }
            while(dp[idx[2]] * 5 <= dp[i - 1]) {
                idx[2]++;
            }
            dp[i] = Math.min(dp[idx[0]] * 2, Math.min(dp[idx[1]] * 3, dp[idx[2]] * 5));
        }
        return dp[n];
    }
}
```