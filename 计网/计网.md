### OSI模型

市面上一共有5中比较常见的模型,分别是4层模型,5层模型和7层模型,但是只有OSI7层模型才是真是的国际化标准模型。

7层分别是物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。

但是由于OSI7层模型只是给出了定义，并没有给出实际的解决方案，所以大多数厂商都使用4层模型。

### 为什么需要TCP协议？

`IP`层是不可靠的，它并不保证网络包的交付，也不能保证网络包的按序到达，也不保证网络包的数据完整性。如果需要保障网络数据包的可靠性，就需要上层TCP来负责。

IP协议是无连接的通信协议，IP不会占用线路，IP只作为一封邮件的发件地和收件点起标识作用，也不会确认数据包是否能够到达，需要上层协议进行传输和控制。

### TCP头部

TCP是一种面向连接的，可靠的，基于字节流的传输层通信协议。

数据传输时，应用层向下层使用TCP协议发送数据流，TCP会把数据流分割成若干个报文段并发送给目标节点的TCP层。

同时，为了保证数据包能够到达，TCP协议会给每个数据包都标上序号，双方收到数据包都需要发送ACK确保包给对方，如果在一个RTT时间内未收到确认将会重传数据包。

并且，TCP会使用一个奇偶校验和函数来校验数据在传输时是否有错误，在发送和接收时都需要计算校验和。

TCP报文头部如下所示：

<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td colspan="8" width="274">
<p align="center">16位源端口号</p>
</td>
<td width="274">
<p align="center">16位目的端口号</p>
</td>
</tr>
<tr>
<td colspan="9" width="548">
<p align="center">32位序列号</p>
</td>
</tr>
<tr>
<td colspan="9" width="548">
<p align="center">32位确认序列号</p>
</td>
</tr>
<tr>
<td width="59">
<p align="center">4位头部长度</p>
</td>
<td width="45">
<p align="center">保留6位</p>
</td>
<td width="28">
<p align="center">U</p>
<p align="center">R</p>
<p align="center">G</p>
</td>
<td width="28">
<p align="center">A</p>
<p align="center">C</p>
<p align="center">K</p>
</td>
<td width="28">
<p align="center">P</p>
<p align="center">S</p>
<p align="center">H</p>
</td>
<td width="28">
<p align="center">R</p>
<p align="center">S</p>
<p align="center">T</p>
</td>
<td width="28">
<p align="center">S</p>
<p align="center">Y</p>
<p align="center">N</p>
</td>
<td width="28">
<p align="center">F</p>
<p align="center">I</p>
<p align="center">N</p>
</td>
<td width="274">
<p align="center">16位窗口大小</p>
</td>
</tr>
<tr>
<td colspan="8" width="274">
<p align="center">16位检验和</p>
</td>
<td width="274">
<p align="center">16位紧急指针</p>
</td>
</tr>
<tr>
<td colspan="9" width="548">
<p align="center">可选项</p>
</td>
</tr>
<tr>
<td colspan="9" width="548">
<p align="center">数据</p>
</td>
</tr>
</tbody>
</table>

换一个更清晰的图：

![6](http://static.codenote.xyz20220219004352.png)

首先是端口号，不管是TCP还是UDP都是不包含IP地址的，因为那是网络层负责的范围，但是TCP和UDP都会有源端口和目的端口。

我们知道两个进程在计算机中通信有管道，内存共享，信号量，消息队列等方法，对于两个进程要通信，也需要能够唯一标识进程的进程号，通常被称为`PID`，但`PID`在本地唯一却不一定在两台主机之间唯一，所以就需要使用端口号来区分，再加上网络层的IP，就可以在网络使用`IP:port`中唯一标识一个进程，也称这种方式为套接字。

接下来是序列号`Seq`，TCP传输中的每个报文都按顺序去编号。比如一段报文的序列号为107，报文的长度为100，那么下一段报文的序列号就是207。用来解决网络包乱序的问题。

在接下来就是确认号`Ack`，表示期望收到对方下一个报文的序列号。比如A向B发送了序列号为301，长度为200的报文，B成功接收后，就会给A发送确认号为501的报文，表示从301-500这些报文已经成功接收了，期待收到的下一个报文序列号是501。

接下来是`Offset`，即数据偏移。由于头部有可选字段，长度不固定，用来指出举例TCP报文的数据距离起始处有多远。 

再接下来就是`Reserved`，表示保留域。保留今后使用，一般会设置为0。

再接下来就是TCP标志位，每个标志位表示一个控制功能，实际上共计有8个，常用的其实只有6个。

`UGE`表示`urgent`，作为紧急指针标志，为1表示紧急指针有效，为0则忽略紧急指针。

`ACK`，作为确认序号标志，为1时表示确认号有效，为0时表示不含确认信息，忽略确认号字段。

`PSH`，表示push标志，为1表示这个报文是带有push标志，接收方在受到后，应该尽快把数据发送给发送方，而不是在缓冲区排队。

`RST`，重置连接标志，用于重置由于主机崩溃或者其他原因而出现错误的连接，或者用于拒绝非法的报文段或者连接请求。

`SYN`，同步序号，用于建立连接过程。

`FIN`，finish标志，用于释放连接，为1是表示没有数据发送了，表示关闭数据流。

再接下来是window窗口，指的是滑动窗口的大小，用来指示接收方和发送方的缓存大小，以此控制发送端的发送速率，从而达到流量控制。

再往下就是`Checksum`，指的是奇偶校验，这个校验和是对整个TCP报文段，包括TCP头部和TCP数据以16位进行计算所得，由发送端进行计算和存储并且由接收端进行校验。

接下来是urgent point。只有当`URG=1`时才有效，指出这个报文段中的紧急报文段的字节数。

最后的一个数据域是TCP可选项，长度可变，定义一些可选参数，比如时间戳，选址字段的末端以及制定了选项字段的边界选项。

### 有一个IP的服务器监听了一个端口，它的TCP最大连接数是多少？

最大TCP连接数=客户端的IP数 * 端口数

对于IPV4来说，IP地址由2 ^ 32个，端口数有2 ^ 16个，服务端的最大TCP连接数约为2 ^ 48。

但是一般来说最大并发数远不能达到理论上限。

- 首先主要是**文件描述符限制**，Socket 都是文件，所以首先要通过 `ulimit` 配置文件描述符的数目；
- 另一个是**内存限制**，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的。

### TCP三次握手

当应用程序希望通过TCP和另一个程序进行通信时，它会发送一个应用请求，这个应用请求必须送到一个地址，当双方握手之后，TCP会在双方之间建立全双工的通信。握手是为了建立连接，TCP的三次握手流程如下。

![TCP 三次握手](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/计算机网络/TCP-三次握手和四次挥手/14.jpg)

上方还有一点小错误，最后的一个报文，还有`Seq Num = client_isn+1`发送，因为需要表示收到了服务端发送来的`ACK`报文。

- 一开始，服务端和客户端都处于`CLOSED`状态，先是服务端主动监听某个端口，处于`LISTEN`状态，再是客户端打开连接，向服务端发送一个同步报文，这个同步报文中，`Seq Num`由客户端随机初始化为`client_isn`，并将`SYN`设置为1，这个同步报文不包含数据，之后客户端发送完这个报文后，进入`SYN_SENT`状态；
- 随后，服务端收到了客户端的同步报文后，服务端也随机初始化一个自己的序列号`Seq Num=server_isn`，把这个序列号填入TCP头部，其次把头部中的应答确认号`Ack Num`设置为`client_isn+1`，表示自己收到了上一个同步报文，接着把头部中的标识位`SYN`和`ACK`都设置为1。最后把这个报文发送给客户端，这个报文即是一个同步报文也是一个确认报文，不包含应用层数据，之后服务端发送完这个报文后，进入`SYN_RECV`状态；
- 之后，客户端就受到了服务端的报文，还需要向服务端发送一个应答报文，表明自己收到了上一步的同步及应答报文，首先把头部中的序列号`Seq Num`设置为`client_isn+1`，表示自己收到了确认报文中的确认号字段，并且也需要把头部中的确认号`Ack Num`设置为`server_isn + 1`，表明自己下一步期待从服务端收到的报文序列号为`server_isn+1`。最后，把报文发送给服务端，客户端发送完报文之后，进入`ESTABLISHED`状态。
- 当服务端收到了来自客户端的应答报文后，也进入`ESTABLISHED`状态，随后，双方就可以互相发送数据了。

同时这里需要注意的是，第三次握手是可以携带数据的，前两次不可以携带数据。

### 为什么需要三次握手？

**主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误**。如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A端发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B**，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。

### SYN攻击

服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。

### 在Linux系统中查看TCP状态？

输入`netstat -natp`指令可以查看本机的所有TCP连接。

![TCP 连接状态查看](http://static.codenote.xyz20220219011640.jpeg)

### TCP四次挥手

挥手是为了终止连接。

![img](http://static.codenote.xyz20220222222527.png)

①.假设客户端发起终止连接请求，发送了`FIN`报文，并且把报文段的首部`FIN`标记为1，序列号`seq`设置为上一步最后一个字节数据的下一个`u`，发送给服务端，这时，客户端的状态由`ESTABLISHED`转换为`FIN-WAIT1`，等待服务端的确认；

②.服务端收到了客户端的`FIN`报文之后，首先需要告诉客户端，表示自己收到了客户端的终止连接请求，但是可能服务端还有数据没有发送完毕，所以只会先回复客户端`ACK`报文，告诉客户端，你的终止连接请求收到了，但是我可能还有数据要发送，所以只会先回复`ACK`数据报，将报文首部的`ACK`标志位置为1，序列号`seq`置为上一步的最后一个数据字节的下一位`v`，并将`ack`置为`u+1`，此时服务端的状态由`ESTABLISHED`转换为`CLOSE-WAIT`，并且继续发送未发送完的数据；

③.客户端此时收到服务端的`ACK`确认报文，知道服务端已经准备终止连接了，进入`FIN-WAIT2`状态，继续接收未发送完的数据。服务端此时继续发送数据，直到把所有数据都发送完之后，服务端发送终止报文`FIN`，将报文首部的`FIN`和`ACK`都置为1，既表示这是为了关闭连接，也表示自己对客户端`FIN`报文的确认，并且将序列号`seq`置为数据的下一个`w`，确认号`ack`仍然置为`u+1`，发送后，服务端的状态由`CLOSE-WAIT`转换为`LAST-WAIT`，等待接收客户端发送的确认报文；

④.客户端收到了服务端发送的`FIN+ACK`报文后，直到服务端没有数据要发送了，也同意终止连接，所以给服务端发送`ACK`报文表明自己收到了，将报文首部的`ACK`置为1，并将序列号`seq`置为`v+1`，也是对客户端的报文的确认，同时，把`ack`置为`w+1`，表明自己收到了`ACK`报文，发送后，客户端进入`TIME-WAIT`状态，需要在等待`2MSL`的时间才可以关闭连接，而服务端收到了客户端的`ACK`报文后，知道客户端同意关闭，所以直接关闭连接，由`LAST-WAIT`状态进入`CLOSED`状态，如果客户端等待了`2MSL`后仍然没有收到服务端的重传报文，说明服务端已经正确关闭，客户端也最终关闭连接，进入`CLOSED`状态。

### 客户端为什么需要再等待2MSL?

1）保证A发送的最后一个ACK报文段能够到达B。

2）防止“已失效的连接请求报文段”出现在本连接中。

- 1）这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态。**若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。**
- 2）A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

### 为什么建立连接需要3次握手，释放连接需要4次挥手？

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

### UDP头部及特点

![image-20220224161256248](http://static.codenote.xyz20220224161256.png)

相比起TCP头部,UDP报文头部简单了许多。

UDP是面向非连接的，无需双方握手；

不维护连接状态，支持同时向多个客户端传输相同的消息；

报文头部较小，额外开销小；

吞吐量只受限于数据生成速率、传输速率以及机器性能；

UDP是尽最大努力交付，不保证可靠支付，不需要维护复杂的链接状态表；

面向报文的，对于不同应用程序的报文，进行拆分或合并，而不是变成字节流；

和TCP的对比

TCP是面向连接的，而UDP无需建立连接；

TCP是相对来说可靠的，有握手，确认，重传机制，UDP不能确定对方是否接收了数据；

TCP是有序的，会对字节流进行排序；

TCP速度更慢，需要做更多处理；

### TCP的滑动窗口

RTT和RTO

RTT是指发送了一个数据包到收到ACK确定后的时间；

RTO是指重传时间间隔；

RTO需要根据RTT计算得出。

TCP使用滑动窗口做流量控制与乱序重排。

对于TCP会话的发送方，一般来说有4类数据

![image-20220224164015526](http://static.codenote.xyz20220224164015.png)

第一部分：已发送且已经收到确认的数据；

第二部分：已发送但是没有收到确认的数据；

第三部分：未发送但是接收方允许接收的数据；

第四部分：未发生且接收方不允许接收的数据；

由第二部分和第三部分共同组成了滑动窗口，滑动过程如下，当收到新的ACK确认时，窗口就进行滑动；

![image-20220224164213625](http://static.codenote.xyz20220224164213.png)

对于TCP的接收方来说，一般来说也有3类数据：

![image-20220224164436860](http://static.codenote.xyz20220224164436.png)

第一部分是已接收且已经确认的部分；

第二部分是未接收但可以接收的部分；

第三部分是未接收且不可以接收的部分；

其中第二部分通常是接收方的滑动窗口；

###  HTTP协议

支持客户端、服务端模式；

![image-20220224171348852](http://static.codenote.xyz20220224171348.png)

HTTP允许传输任意数据类型的数据，需要用content-type标记；

简单快速，客户端请求数据的时候，只需声明请求方法和路径；

无连接，服务器处理完请求后，就会断开连接，减少请求数量，从HTTP1.0开始默认是长连接，会等待一段时间；

无状态，协议对于事务处理没有状态保持；

### HTTP请求结构

![image-20220224171824204](http://static.codenote.xyz20220224171824.png)

<hr/>

![image-20220224172706372](http://static.codenote.xyz20220224172706.png)

### 在浏览器输入url后，按下回车之后历经的流程

浏览器根据url中的域名部分，逐层查询DNS缓存，解析域名对应的IP地址，DNS缓存从近到远依次是浏览器缓存，系统缓存，路由器缓存，ISP（网络供应商）服务器缓存，根域名服务器缓存，顶级域名服务器缓存，从哪个服务器找到IP，则直接返回，不再继续查询；

紧接着根据上一步的IP地址，建立三次握手的TCP连接；

浏览器发送读取url的HTTP请求；

服务器处理收到的请求，并且返回带有HTML文本的HTTP返回报文；

浏览器解析和渲染页面；

最后浏览器通过四次挥手释放TCP连接，连接结束；

### HTTP状态码

由3位数字组成，第一位数字表示响应的类别；

1xx：指示信息--表示请求已接收，继续处理；

2xx：成功--表示请求已被成功接收、理解、接受

3xx：重定向--要完成请求必须进行更进一步的操作；

4xx：客户端错误--请求有语法错误或者请求无法实现；

5xx：服务端错误--服务器未能实现合法的请求；

常见状态码：

200	`OK`：正常返回信息；

400	`Bad Request`：客户端请求有语法错误、不能被服务器所理解；

401	`Unauthorized`：请求未经授权，这个状态码必须和`WWW-Authenticate`报头域一起使用；

403	`Forbidden`：服务器收到请求，但是拒绝提供服务；

404	`Not Found`：请求资源不存在，如输入了错误的url；

500	`Internal Server Error`：服务器发生不可预期的错误；

503	`Server Unavailable`：服务器当前不能处理客户端的请求，一段时间后可能恢复正常；

### GET和POST的区别

HTTP报文层面：

GET将请求信息放在URL，POST放在报文体；

长度：

GET请求的长度有限制，而POST请求的长度没有限制；

数据库层次：

GET符合幂等性和安全性，POST不符合幂等性；

因为GET请求是做查询使用的，不会改变数据库中的数据，所以是幂等性和安全的，而POST可能会改变数据库的数据，所以不是幂等的；

缓存层面：

GET请求可以被缓存、被存储，而POST请求不行；

### Cookie和Session

Cookie是由服务器发送给客户端的特殊信息，以文本的形式存放在客户端，客户端每次发送请求时，都会带上这些信息；

客户端再次请求的时候，就会把Cookie回发；

当服务器接收到请求后，就会把Cookie解析并生产与客户端相对应的内容；

![image-20220224215430912](http://static.codenote.xyz20220224215430.png)

Session是服务器端的机制，在服务器上保存的信息；

解析客户端请求并操作session id，按需保存状态信息；

Session的实现方式一：使用Cookie来实现

![image-20220224215721123](http://static.codenote.xyz20220224215721.png)

实现方式二：使用URL回写实现

服务器返回的url中携带session id，这样访问任何一个url都可以携带session id。

Tomcat最早同时使用两种机制，如果客户端支持cookie，那么就停止使用url回写，如果禁用cookie，那么就一直使用url回写。

区别：

Cookie数据存放在客户端的浏览器上，Session数据存放在服务器上；

Session相对于Cookie更加安全，因为Cookie可以通过抓包抓取到，可以使用Cookie欺骗技术欺骗服务端；

如果要考虑减轻服务器负担，应该使用Cookie；

### HTTPS

![image-20220224220336099](http://static.codenote.xyz20220224220336.png)

SSL（安全套接层），为网络通信提供安全及数据完整性的一种安全协议；

是操作系统对外的API，SSL3.0后更名为TLS；

采用身份验证和数据加密保证网络通信的安全和数据的完整性；

对称加密：加密和解密都使用同一个密钥；

非对称加密：加密和解密使用的密钥不同；

哈希算法：将任意长度的信息转换为固定长度的指，算法不可逆；

数字签名：证明某个消息或者文件是某人发出、认同的；

HTTPS的流程：

浏览器将支持的加密算法信息发送给服务器；

服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器；

浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器；

服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器；

浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据；

### Socket

![image-20220224221713126](http://static.codenote.xyz20220224221713.png)

