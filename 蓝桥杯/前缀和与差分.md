## 前缀和

前缀和指数组中前n个数的和（1 < n < 数列长度），利用前缀和可以求出`数列任一区间内`数的和

前缀和$S_i = a_1+a_2+a_3+a_4+...+a_i$，即为前$i$个数的和，这里推荐一定要从1开始。

本质是高中数列的一个知识点，$a_i = S(i) - S(i-1)$。

如果不利用前缀和，那么就是从$a[l]$加到$a[r]$，时间复杂度为$O(n)$，如果有前缀和数组，那么我们可以直接计算出$sum = S_r-S_{l-1}$。

$S_r = a_1+a_2+a_3+...+a_{r-1}+a_r$

$S_{l-1}=a_1+a_2+a_3+...+a_{l-2}+a_{l-1}$

故$a_l+a_{l+1}+a_{l+2}+...+a_{r-1}+a_r = S_r -S_{l-1}$

```cpp
#include <iostream>
using namespace std;

const int N = 100010;
int n, m;
int a[N], s[N];

int main() {
	scanf("%d%d", &n, &m);

	for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i]; // 初始化前缀和

	while (m -- ) {
		int l, r;
		scanf("%d%d", &l, &r);
		// 计算任一区间和
		printf("%d\n", s[r] - s[l - 1]);
	}
	return 0;
}
```

## 二维前缀和

用于快速地求出某个子矩阵中所有数的和。

$s_{ij}$表示为以$a_{ij}$为右下角的子矩阵的和。

若想求$(x_1,y_1)$与$(x_2,y_2)$围成的小矩形的和，$sum=s_{x_2y2}-s_{x2y1-1}-s_{x1-1y2}+s_{x1-1y1-1}$。

$s_{ij}=s_{i-1j}+s_{ij-1}-s_{i-1j-1}+a_{ij}$。

```cpp
#include <iostream>

using namespace std;

const int N = 1010;
int n, m, q;
int a[N][N], s[N][N];
int main() {
	scanf("%d%d%d", &n, &m, &q);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) scanf("%d", &a[i][j]);

	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
	while (q--) {
		int x1, y1, x2, y2;
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		printf("%d\n", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
	}
	return 0;
}

```



## 差分